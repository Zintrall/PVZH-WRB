<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PVZH Win Rate Browser</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #bb86fc;
            --error-color: #cf6679;
            --success-color: #03dac6;
            --button-bg: #3700b3;
            --button-hover: #6200ee;
            --table-header: #2d2d2d;
            --table-row-odd: #262626;
            --table-row-even: #2d2d2d;
            --border-color: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: var(--accent-color);
        }

        .filter-block {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .filter-block h2 {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: var(--button-bg);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--button-hover);
        }

        button.active {
            background-color: var(--accent-color);
        }

        .time-window, .patch-select, .tournament-select, .player-select, .opponent-select {
            display: none;
            margin-top: 15px;
        }

        .checkbox-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .checkbox-item {
            margin-bottom: 8px;
        }

        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            cursor: pointer;
        }

        input[type="date"], input[type="text"], select {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: #333;
            color: var(--text-color);
        }

        .search-bar {
            margin-bottom: 15px;
        }

        .hero-grid {
            margin-top: 30px;
            overflow-x: auto;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            min-width: 1000px;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--table-header);
            position: sticky;
            top: 0;
        }

        tr:nth-child(odd) {
            background-color: var(--table-row-odd);
        }

        tr:nth-child(even) {
            background-color: var(--table-row-even);
        }

        .hero-cell {
            font-weight: bold;
            background-color: var(--table-header);
        }

        .winrate-cell {
            transition: background-color 0.3s;
        }

        .stats-summary {
            margin-top: 20px;
            background-color: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            color: var(--accent-color);
        }

        .error {
            background-color: var(--error-color);
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .search-button-container {
            margin-top: 20px;
            text-align: center;
        }

        .search-button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: var(--accent-color);
        }

        /* For mobile responsiveness */
        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
            }
            
            .hero-grid {
                overflow-x: scroll;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PVZH Win Rate Browser</h1>
        
        <!-- Data/Patch Block -->
        <div class="filter-block">
            <h2>
                <span>Data Selection</span>
                <div class="button-group">
                    <button id="date-button" class="active">Date</button>
                    <button id="patch-button">Patch</button>
                </div>
            </h2>
            
            <div class="time-window" id="time-window">
                <div class="date-range">
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date">
                    
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date">
                </div>
            </div>
            
            <div class="patch-select" id="patch-select">
                <div class="search-bar">
                    <input type="text" id="patch-search" placeholder="Search patches...">
                </div>
                <div class="checkbox-list" id="patch-list">
                    <!-- Patches will be populated here -->
                    <div class="loading">Loading patches...</div>
                </div>
            </div>
        </div>
        
        <!-- Tournament Block -->
        <div class="filter-block">
            <h2>Tournaments</h2</h2>>
            <div class="tournament-select" id="tournament-select">
                <div class="search-bar">
                    <input type="text" id="tournament-search" placeholder="Search tournaments...">
                </div>
                <div class="checkbox-list" id="tournament-list">
                    <!-- Tournaments will be populated here -->
                    <div class="loading">Loading tournaments...</div>
                </div>
            </div>
        </div>
        
        <!-- Player Block -->
        <div class="filter-block">
            <h2>
                <span>Player Selection</span>
                <div class="button-group">
                    <button id="players-button" class="active">Players</button>
                    <button id="opponent-button">Opponent</button>
                </div>
            </h2>
            
            <div class="player-select" id="player-select">
                <div class="search-bar">
                    <input type="text" id="player-search" placeholder="Search players...">
                </div>
                <div class="checkbox-list" id="player-list">
                    <!-- Players will be populated here -->
                    <div class="loading">Loading players...</div>
                </div>
            </div>
            
            <div class="opponent-select" id="opponent-select">
                <div class="search-bar">
                    <input type="text" id="opponent-search" placeholder="Search opponents...">
                    <div id="opponent-results" class="checkbox-list">
                        <!-- Opponent search results will be populated here -->
                    </div>
                </div>
                <div id="selected-opponent">
                    <!-- Selected opponent will be shown here -->
                </div>
            </div>
        </div>
        
        <div class="search-button-container">
            <button id="search-button" class="search-button">Generate Win Rate Table</button>
        </div>
        
        <!-- Results Table -->
        <div class="hero-grid" id="hero-grid">
            <!-- Hero vs Hero grid will be generated here -->
        </div>
        
        <!-- Stats Summary -->
        <div class="stats-summary" id="stats-summary">
            <!-- Summary statistics will be displayed here -->
        </div>
    </div>

    <script>
        // Hero data
        const heroes = {
            zombies: ["sb", "sm", "if", "rb", "eb", "bf", "pb", "im", "zm", "nt", "hg"],
            plants: ["gs", "sf", "wk", "cz", "sp", "ct", "gk", "nc", "ro", "cc", "bc"]
        };

        // Hero display names (you can customize these)
        const heroNames = {
            "sb": "Super Brainz",
            "sm": "Smash",
            "if": "Impfinity",
            "rb": "Rustbolt",
            "eb": "Electric Boogaloo",
            "bf": "Brain Freeze",
            "pb": "Professor Brainstorm",
            "im": "Immorticia",
            "zm": "Z-Mech",
            "nt": "Neptuna",
            "hg": "Huge-Gigantacus",
            "gs": "Green Shadow",
            "sf": "Solar Flare",
            "wk": "Wall-Knight",
            "cz": "Chompzilla",
            "sp": "Spudow",
            "ct": "Citron",
            "gk": "Grass Knuckles",
            "nc": "Nightcap",
            "ro": "Rose",
            "cc": "Captain Combustible",
            "bc": "Beta-Carrotina"
        };

        // Global variables
        let allPatches = [];
        let allTournaments = [];
        let allPlayers = [];
        let matchData = [];

        // Element references
        const dateButton = document.getElementById('date-button');
        const patchButton = document.getElementById('patch-button');
        const timeWindow = document.getElementById('time-window');
        const patchSelect = document.getElementById('patch-select');
        const tournamentSelect = document.getElementById('tournament-select');
        const playersButton = document.getElementById('players-button');
        const opponentButton = document.getElementById('opponent-button');
        const playerSelect = document.getElementById('player-select');
        const opponentSelect = document.getElementById('opponent-select');
        const searchButton = document.getElementById('search-button');

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Show the time window by default
            timeWindow.style.display = 'block';
            tournamentSelect.style.display = 'block';
            playerSelect.style.display = 'block';

            // Set default date range (last 30 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30);
            
            document.getElementById('end-date').valueAsDate = endDate;
            document.getElementById('start-date').valueAsDate = startDate;
            
            // Initialize the data
            fetchPatches();
            fetchPlayers();
        });

        // Toggle between Date and Patch selection
        dateButton.addEventListener('click', () => {
            dateButton.classList.add('active');
            patchButton.classList.remove('active');
            timeWindow.style.display = 'block';
            patchSelect.style.display = 'none';
        });

        patchButton.addEventListener('click', () => {
            patchButton.classList.add('active');
            dateButton.classList.remove('active');
            patchSelect.style.display = 'block';
            timeWindow.style.display = 'none';
        });

        // Toggle between Players and Opponent selection
        playersButton.addEventListener('click', () => {
            playersButton.classList.add('active');
            opponentButton.classList.remove('active');
            playerSelect.style.display = 'block';
            opponentSelect.style.display = 'none';
        });

        opponentButton.addEventListener('click', () => {
            opponentButton.classList.add('active');
            playersButton.classList.remove('active');
            opponentSelect.style.display = 'block';
            playerSelect.style.display = 'none';
        });

        // Search functionality
        document.getElementById('patch-search').addEventListener('input', (e) => {
            filterCheckboxList('patch-list', e.target.value);
        });

        document.getElementById('tournament-search').addEventListener('input', (e) => {
            filterCheckboxList('tournament-list', e.target.value);
        });

        document.getElementById('player-search').addEventListener('input', (e) => {
            filterCheckboxList('player-list', e.target.value);
        });

        document.getElementById('opponent-search').addEventListener('input', (e) => {
            searchOpponents(e.target.value);
        });

        // Filter checkbox list based on search input
        function filterCheckboxList(listId, query) {
            const list = document.getElementById(listId);
            const items = list.getElementsByClassName('checkbox-item');
            
            for (let i = 0; i < items.length; i++) {
                const label = items[i].querySelector('label');
                if (label.textContent.toLowerCase().includes(query.toLowerCase())) {
                    items[i].style.display = '';
                } else {
                    items[i].style.display = 'none';
                }
            }
        }

        // Search opponents
        function searchOpponents(query) {
            if (query.length < 2) {
                document.getElementById('opponent-results').innerHTML = '';
                return;
            }
            
            const matchingPlayers = allPlayers.filter(player => 
                player.toLowerCase().includes(query.toLowerCase())
            );
            
            const resultsHtml = matchingPlayers.map(player => 
                `<div class="checkbox-item">
                    <label>${player}</label>
                    <button class="select-opponent" data-player="${player}">Select</button>
                </div>`
            ).join('');
            
            document.getElementById('opponent-results').innerHTML = resultsHtml;
            
            // Add event listeners to select buttons
            document.querySelectorAll('.select-opponent').forEach(button => {
                button.addEventListener('click', () => {
                    selectOpponent(button.dataset.player);
                });
            });
        }

        // Select an opponent
        function selectOpponent(player) {
            document.getElementById('selected-opponent').innerHTML = 
                `<div class="selected-player">
                    <h3>Selected Opponent: ${player}</h3>
                    <button id="clear-opponent">Clear</button>
                </div>`;
            
            document.getElementById('opponent-search').value = '';
            document.getElementById('opponent-results').innerHTML = '';
            
            document.getElementById('clear-opponent').addEventListener('click', () => {
                document.getElementById('selected-opponent').innerHTML = '';
            });
        }

        // Fetch patches
        async function fetchPatches() {
            try {
                // Get list of directories in the datafiles folder
                const repoOwner = 'YOUR_GITHUB_USERNAME'; // Replace with your GitHub username
                const repoName = 'YOUR_REPO_NAME'; // Replace with your repo name
                const path = 'datafiles';
                
                const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch patches');
                }
                
                const data = await response.json();
                allPatches = data
                    .filter(item => item.type === 'dir')
                    .map(item => item.name);
                
                renderPatchList();
                fetchTournaments();
            } catch (error) {
                console.error('Error fetching patches:', error);
                // Fallback to dummy data if fetch fails
                allPatches = ['patch_1.0', 'patch_1.1', 'patch_2.0', 'patch_2.1', 'patch_3.0'];
                renderPatchList();
                fetchTournaments();
            }
        }

        // Render patch list
        function renderPatchList() {
            const patchList = document.getElementById('patch-list');
            patchList.innerHTML = allPatches.map((patch, index) => 
                `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="patch" value="${patch}" ${index === allPatches.length - 1 ? 'checked' : ''}>
                        ${patch}
                    </label>
                </div>`
            ).join('');
            
            // When patches are selected, update tournament list
            document.querySelectorAll('input[name="patch"]').forEach(checkbox => {
                checkbox.addEventListener('change', fetchTournaments);
            });
        }

        // Fetch tournaments based on selected patches
        async function fetchTournaments() {
            const selectedPatches = Array.from(document.querySelectorAll('input[name="patch"]:checked'))
                .map(input => input.value);
            
            if (selectedPatches.length === 0) {
                document.getElementById('tournament-list').innerHTML = '<div class="error">No patches selected</div>';
                return;
            }
            
            document.getElementById('tournament-list').innerHTML = '<div class="loading">Loading tournaments...</div>';
            
            try {
                const repoOwner = 'YOUR_GITHUB_USERNAME'; // Replace with your GitHub username
                const repoName = 'YOUR_REPO_NAME'; // Replace with your repo name
                
                let allTournamentsData = [];
                
                // Fetch tournaments for each selected patch
                for (const patch of selectedPatches) {
                    const path = `datafiles/${patch}`;
                    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;
                    
                    try {
                        const response = await fetch(apiUrl);
                        
                        if (response.ok) {
                            const data = await response.json();
                            const tournaments = data
                                .filter(item => item.type === 'file' && item.name.endsWith('.txt'))
                                .map(item => ({
                                    name: item.name.replace('.txt', ''),
                                    patch: patch,
                                    fullName: `${patch}/${item.name}`
                                }));
                            
                            allTournamentsData = allTournamentsData.concat(tournaments);
                        }
                    } catch (error) {
                        console.error(`Error fetching tournaments for patch ${patch}:`, error);
                    }
                }
                
                allTournaments = allTournamentsData;
                renderTournamentList();
            } catch (error) {
                console.error('Error fetching tournaments:', error);
                // Fallback to dummy data if fetch fails
                allTournaments = generateDummyTournaments(selectedPatches);
                renderTournamentList();
            }
        }

        // Generate dummy tournaments (fallback if GitHub API fails)
        function generateDummyTournaments(patches) {
            const tournaments = [];
            patches.forEach(patch => {
                const count = Math.floor(Math.random() * 5) + 1;
                for (let i = 1; i <= count; i++) {
                    tournaments.push({
                        name: `tournament_${i}`,
                        patch: patch,
                        fullName: `${patch}/tournament_${i}.txt`
                    });
                }
            });
            return tournaments;
        }

        // Render tournament list
        function renderTournamentList() {
            const tournamentList = document.getElementById('tournament-list');
            if (allTournaments.length === 0) {
                tournamentList.innerHTML = '<div class="error">No tournaments found for the selected patches</div>';
                return;
            }
            
            tournamentList.innerHTML = allTournaments.map(tournament => 
                `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="tournament" value="${tournament.fullName}" data-patch="${tournament.patch}" checked>
                        ${tournament.name} (${tournament.patch})
                    </label>
                </div>`
            ).join('');
        }

        // Fetch players
        async function fetchPlayers() {
            try {
                const repoOwner = 'YOUR_GITHUB_USERNAME'; // Replace with your GitHub username
                const repoName = 'YOUR_REPO_NAME'; // Replace with your repo name
                const filePath = 'playernames.txt';
                
                const apiUrl = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/${filePath}`;
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch player names');
                }
                
                const data = await response.text();
                allPlayers = data.split('\n').filter(name => name.trim() !== '');
                renderPlayerList();
            } catch (error) {
                console.error('Error fetching players:', error);
                // Fallback to dummy data if fetch fails
                allPlayers = ['Player1', 'Player2', 'Player3', 'Player4', 'Player5', 'Player6', 'Player7', 'Player8', 'Player9', 'Player10'];
                renderPlayerList();
            }
        }

        // Render player list
        function renderPlayerList() {
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = allPlayers.map(player => 
                `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="player" value="${player}">
                        ${player}
                    </label>
                </div>`
            ).join('');
        }

        // Generate win rate table
        searchButton.addEventListener('click', generateWinRateTable);

        function generateWinRateTable() {
            const heroGrid = document.getElementById('hero-grid');
            heroGrid.innerHTML = '<div class="loading">Generating win rate table...</div>';
            
            // In a real implementation, this would fetch and process your data
            // For now, we'll simulate with dummy data
            setTimeout(() => {
                fetchMatchData();
            }, 1000);
        }

        // Fetch match data
        async function fetchMatchData() {
            const heroGrid = document.getElementById('hero-grid');
            const statsSummary = document.getElementById('stats-summary');
            
            heroGrid.innerHTML = '<div class="loading">Loading match data...</div>';
            statsSummary.innerHTML = '';
            
            // Determine date range or patches
            let dataFilter;
            if (dateButton.classList.contains('active')) {
                dataFilter = {
                    type: 'date',
                    startDate: document.getElementById('start-date').value,
                    endDate: document.getElementById('end-date').value
                };
            } else {
                dataFilter = {
                    type: 'patch',
                    patches: Array.from(document.querySelectorAll('input[name="patch"]:checked'))
                        .map(input => input.value)
                };
            }
            
            // Get selected tournaments
            const selectedTournaments = Array.from(document.querySelectorAll('input[name="tournament"]:checked'))
                .map(input => input.value);
            
            // Get player filter type and selection
            let playerFilter;
            if (playersButton.classList.contains('active')) {
                playerFilter = {
                    type: 'players',
                    players: Array.from(document.querySelectorAll('input[name="player"]:checked'))
                        .map(input => input.value)
                };
            } else {
                const selectedOpponent = document.getElementById('selected-opponent').textContent.trim();
                playerFilter = {
                    type: 'opponent',
                    opponent: selectedOpponent ? selectedOpponent.replace('Selected Opponent: ', '').replace('Clear', '').trim() : null
                };
            }
            
            try {
                // Fetch real match data from GitHub repository
                const matchResults = await fetchRealMatchData(dataFilter, selectedTournaments, playerFilter);
                matchData = matchResults;
                renderWinRateTable(matchData);
                renderStatsSummary(matchData);
            } catch (error) {
                console.error('Error fetching match data:', error);
                heroGrid.innerHTML = `<div class="error">Error loading data: ${error.message}</div>`;
                
                // Fallback to dummy data for demo purposes
                matchData = generateDummyMatchData();
                renderWinRateTable(matchData);
                renderStatsSummary(matchData);
            }
        }

        // Generate dummy match data (replace with actual data fetching)
        function generateDummyMatchData() {
            const data = [];
            
            // Create a data structure to hold the match results
            // This would normally be populated from your text files
            
            // Generate some dummy data for every hero combination
            heroes.zombies.forEach(zombie => {
                heroes.plants.forEach(plant => {
                    // Random win count between 0 and 100
                    const zombieWins = Math.floor(Math.random() * 100);
                    const plantWins = Math.floor(Math.random() * 100);
                    
                    data.push({
                        zombie,
                        plant,
                        zombieWins,
                        plantWins,
                        totalMatches: zombieWins + plantWins,
                        zombieWinRate: zombieWins / (zombieWins + plantWins)
                    });
                });
            });
            
            return data;
        }

        // Render win rate table
        function renderWinRateTable(data) {
            const heroGrid = document.getElementById('hero-grid');
            
            // Create table
            let tableHtml = '<table>';
            
            // Header row with plant heroes
            tableHtml += '<tr><th></th>'; // Empty corner cell
            heroes.plants.forEach(plant => {
                tableHtml += `<th title="${heroNames[plant]}">${plant.toUpperCase()}</th>`;
            });
            tableHtml += '<th>Total</th></tr>';
            
            // Create a row for each zombie hero
            heroes.zombies.forEach(zombie => {
                tableHtml += `<tr><td class="hero-cell" title="${heroNames[zombie]}">${zombie.toUpperCase()}</td>`;
                
                let totalMatches = 0;
                let totalWins = 0;
                
                // Create a cell for each plant vs zombie matchup
                heroes.plants.forEach(plant => {
                    const matchup = data.find(m => m.zombie === zombie && m.plant === plant);
                    
                    if (matchup) {
                        totalMatches += matchup.totalMatches;
                        totalWins += matchup.zombieWins;
                        
                        const winRate = matchup.zombieWinRate;
                        const winRatePercent = (winRate * 100).toFixed(1) + '%';
                        const matches = matchup.totalMatches;
                        
                        // Color coding
                        let bgColor = getWinRateColor(winRate);
                        
                        tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${matches} games">
                            ${winRatePercent}<br><small>(${matches})</small>
                        </td>`;
                    } else {
                        tableHtml += '<td class="winrate-cell">N/A</td>';
                    }
                });
                
                // Add total column
                const overallWinRate = totalMatches > 0 ? totalWins / totalMatches : 0;
                const overallWinRatePercent = (overallWinRate * 100).toFixed(1) + '%';
                const bgColor = getWinRateColor(overallWinRate);
                
                tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${totalMatches} games">
                    ${overallWinRatePercent}<br><small>(${totalMatches})</small>
                </td>`;
                
                tableHtml += '</tr>';
            });
            
            // Add a total row for plants
            tableHtml += '<tr><td class="hero-cell">Total</td>';
            
            heroes.plants.forEach(plant => {
                const plantMatches = data.filter(m => m.plant === plant);
                const totalMatches = plantMatches.reduce((sum, m) => sum + m.totalMatches, 0);
                const plantWins = plantMatches.reduce((sum, m) => sum + m.plantWins, 0);
                const plantWinRate = totalMatches > 0 ? plantWins / totalMatches : 0;
                const plantWinRatePercent = (plantWinRate * 100).toFixed(1) + '%';
                const bgColor = getWinRateColor(1 - plantWinRate); // Invert since this is from zombie perspective
                
                tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${totalMatches} games">
                    ${plantWinRatePercent}<br><small>(${totalMatches})</small>
                </td>`;
            });
            
            // Overall total
            const allMatches = data.reduce((sum, m) => sum + m.totalMatches, 0);
            const allZombieWins = data.reduce((sum, m) => sum + m.zombieWins, 0);
            const overallZombieWinRate = allMatches > 0 ? allZombieWins / allMatches : 0;
            const overallZombieWinRatePercent = (overallZombieWinRate * 100).toFixed(1) + '%';
            const bgColor = getWinRateColor(overallZombieWinRate);
            
            tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${allMatches} games">
                ${overallZombieWinRatePercent}<br><small>(${allMatches})</small>
            </td>`;
            
            tableHtml += '</tr>';
            tableHtml += '</table>';
            
            heroGrid.innerHTML = tableHtml;
        }

        // Get color for win rate cell
        function getWinRateColor(winRate) {
            if (winRate < 0.4) {
                // Deep red for very low win rates
                return `rgba(255, 0, 0, ${0.4 + (0.4 - winRate) * 2})`;
            } else if (winRate < 0.5) {
                // Lighter red as win rate approaches 50%
                return `rgba(255, 0, 0, ${(0.5 - winRate) * 4})`;
            } else if (winRate > 0.6) {
                // Deep green for very high win rates
                return `rgba(0, 255, 0, ${0.4 + (winRate - 0.6) * 2})`;
            } else if (winRate > 0.5) {
                // Lighter green as win rate approaches 50%
                return `rgba(0, 255, 0, ${(winRate - 0.5) * 4})`;
            } else {
                // Exactly 50% is neutral
                return 'transparent';
            }
        }

        // Render stats summary
        function renderStatsSummary(data) {
            const statsSummary = document.getElementById('stats-summary');
            
            // Calculate most played heroes
            const heroPlayCount = {};
            
            heroes.zombies.forEach(zombie => {
                heroPlayCount[zombie] = data
                    .filter(m => m.zombie === zombie)
                    .reduce((sum, m) => sum + m.totalMatches, 0);
            });
            
            heroes.plants.forEach(plant => {
                heroPlayCount[plant] = data
                    .filter(m => m.plant === plant)
                    .reduce((sum, m) => sum + m.totalMatches, 0);
            });
            
            // Sort heroes by play count
            const sortedHeroes = Object.entries(heroPlayCount)
                .sort((a, b) => b[1] - a[1])
                .map(([hero, count]) => ({
                    hero,
                    count,
                    type: heroes.zombies.includes(hero) ? 'Zombie' : 'Plant'
                }));
            
            let summaryHtml = '<h2>Hero Play Stats</h2>';
            
            // Most played heroes
            summaryHtml += '<div class="stats-section"><h3>Most Played Heroes</h3><ol>';
            sortedHeroes.slice(0, 5).forEach(item => {
                summaryHtml += `<li>${heroNames[item.hero]} (${item.type}): ${item.count} games</li>`;
            });
            summaryHtml += '</ol></div>';
            
            // Best performing heroes (by win rate)
            const zombieHeroStats = heroes.zombies.map(zombie => {
                const matches = data.filter(m => m.zombie === zombie);
                const totalMatches = matches.reduce((sum, m) => sum + m.totalMatches, 0);
                const wins = matches.reduce((sum, m) => sum + m.zombieWins, 0);
                const winRate = totalMatches > 0 ? wins / totalMatches : 0;
                return { hero: zombie, winRate, matches: totalMatches };
            }).filter(h => h.matches > 0);
            
            const plantHeroStats = heroes.plants.map(plant => {
                const matches = data.filter(m => m.plant === plant);
                const totalMatches = matches.reduce((sum, m) => sum + m.totalMatches, 0);
                const wins = matches.reduce((sum, m) => sum + m.plantWins, 0);
                const winRate = totalMatches > 0 ? wins / totalMatches : 0;
                return { hero: plant, winRate, matches: totalMatches };
            }).filter(h => h.matches > 0);
            
            // Best zombie heroes
            const bestZombies = [...zombieHeroStats].sort((a, b) => b.winRate - a.winRate);
            
            summaryHtml += '<div class="stats-section"><h3>Best Performing Zombie Heroes</h3><ol>';
            bestZombies.slice(0, 3).forEach(item => {
                const winRatePercent = (item.winRate * 100).toFixed(1) + '%';
                summaryHtml += `<li>${heroNames[item.hero]}: ${winRatePercent} win rate (${item.matches} games)</li>`;
            });
            summaryHtml += '</ol></div>';
            
            // Best plant heroes
            const bestPlants = [...plantHeroStats].sort((a, b) => b.winRate - a.winRate);
            
            summaryHtml += '<div class="stats-section"><h3>Best Performing Plant Heroes</h3><ol>';
            bestPlants.slice(0, 3).forEach(item => {
                const winRatePercent = (item.winRate * 100).toFixed(1) + '%';
                summaryHtml += `<li>${heroNames[item.hero]}: ${winRatePercent} win rate (${item.matches} games)</li>`;
            });
            summaryHtml += '</ol></div>';
            
            // Overall faction stats
            const totalMatches = data.reduce((sum, m) => sum + m.totalMatches, 0);
            const zombieWins = data.reduce((sum, m) => sum + m.zombieWins, 0);
            const plantWins = data.reduce((sum, m) => sum + m.plantWins, 0);
            
            const zombieWinRate = totalMatches > 0 ? (zombieWins / totalMatches * 100).toFixed(1) + '%' : 'N/A';
            const plantWinRate = totalMatches > 0 ? (plantWins / totalMatches * 100).toFixed(1) + '%' : 'N/A';
            
            summaryHtml += `<div class="stats-section"><h3>Overall Faction Stats</h3>
                <p>Total Matches: ${totalMatches}</p>
                <p>Zombies: ${zombieWinRate} (${zombieWins} wins)</p>
                <p>Plants: ${plantWinRate} (${plantWins} wins)</p>
            </div>`;
            
            statsSummary.innerHTML = summaryHtml;
        }

        // Function to fetch the actual data from GitHub repo
        async function fetchDataFromGitHub(tournamentFullPath) {
            try {
                const repoOwner = 'YOUR_GITHUB_USERNAME'; // Replace with your GitHub username
                const repoName = 'YOUR_REPO_NAME'; // Replace with your repo name
                
                const response = await fetch(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/datafiles/${tournamentFullPath}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data for ${tournamentFullPath} (${response.status})`);
                }
                const data = await response.text();
                return processGameData(data.split('\n'));
            } catch (error) {
                console.error(`Error fetching data for ${tournamentFullPath}:`, error);
                return [];
            }
        }

        // Process the raw text data into structured format
        function processGameData(lines) {
            return lines
                .filter(line => line.trim().length > 0)
                .map(line => {
                    const [timestamp, winner, loser, winningHero, losingHero, ...rest] = line.split('|');
                    return {
                        timestamp,
                        winner,
                        loser,
                        winningHero,
                        losingHero
                    };
                });
        }

        // Function to fetch and process the actual match data from text files
        async function fetchRealMatchData(dataFilter, selectedTournaments, playerFilter) {
            let allData = [];
            
            // Fetch data for each selected tournament
            for (const tournamentPath of selectedTournaments) {
                try {
                    const tournamentData = await fetchDataFromGitHub(tournamentPath);
                    
                    // Apply date filter if needed
                    if (dataFilter.type === 'date' && dataFilter.startDate && dataFilter.endDate) {
                        const startDate = new Date(dataFilter.startDate);
                        const endDate = new Date(dataFilter.endDate);
                        endDate.setHours(23, 59, 59); // Include the whole end day
                        
                        const filteredData = tournamentData.filter(match => {
                            const matchDate = new Date(match.timestamp);
                            return matchDate >= startDate && matchDate <= endDate;
                        });
                        
                        allData = allData.concat(filteredData);
                    } else {
                        // No date filter, just add all data
                        allData = allData.concat(tournamentData);
                    }
                } catch (error) {
                    console.error(`Error processing tournament data for ${tournamentPath}:`, error);
                }
            }
            
            // Apply player filters
            if (playerFilter.type === 'players' && playerFilter.players.length > 0) {
                allData = allData.filter(match => 
                    playerFilter.players.includes(match.winner) || 
                    playerFilter.players.includes(match.loser)
                );
            } else if (playerFilter.type === 'opponent' && playerFilter.opponent) {
                allData = allData.filter(match => 
                    match.winner === playerFilter.opponent || 
                    match.loser === playerFilter.opponent
                );
            }
            
            // Process the data into the format needed for the win rate table
            return processMatchDataForWinRateTable(allData);
        }
        
        function processMatchDataForWinRateTable(matchData) {
            // Create a data structure to hold all matchups
            const matchups = {};
            
            // Initialize all matchups with zero counts
            heroes.zombies.forEach(zombie => {
                heroes.plants.forEach(plant => {
                    const key = `${zombie}-${plant}`;
                    matchups[key] = {
                        zombie,
                        plant,
                        zombieWins: 0,
                        plantWins: 0,
                        totalMatches: 0,
                        zombieWinRate: 0
                    };
                });
            });
            
            // Process each match
            matchData.forEach(match => {
                let zombieHero, plantHero, zombieWin;
                
                // Determine which hero is zombie and which is plant
                if (heroes.zombies.includes(match.winningHero)) {
                    zombieHero = match.winningHero;
                    plantHero = match.losingHero;
                    zombieWin = true;
                } else {
                    zombieHero = match.losingHero;
                    plantHero = match.winningHero;
                    zombieWin = false;
                }
                
                // Update the matchup stats
                const key = `${zombieHero}-${plantHero}`;
                if (matchups[key]) {
                    matchups[key].totalMatches++;
                    
                    if (zombieWin) {
                        matchups[key].zombieWins++;
                    } else {
                        matchups[key].plantWins++;
                    }
                    
                    // Update win rate
                    matchups[key].zombieWinRate = matchups[key].zombieWins / matchups[key].totalMatches;
                }
            });
            
            // Convert the object to an array
            return Object.values(matchups).filter(m => m.totalMatches > 0);
        }
    </script>
</body>
</html>