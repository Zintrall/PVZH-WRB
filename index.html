<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>PVZH Win Rate Browser</title>
        <style>
            :root {
                --bg-color: #121212;
                --card-bg: #1e1e1e;
                --text-color: #e0e0e0;
                --accent-color: #bb86fc;
                --error-color: #cf6679;
                --success-color: #03dac6;
                --button-bg: #3700b3;
                --button-hover: #6200ee;
                --table-header: #2d2d2d;
                --table-row-odd: #262626;
                --table-row-even: #2d2d2d;
                --border-color: #333333;
                --muted-text: #888888;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background-color: var(--bg-color);
                color: var(--text-color);
                line-height: 1.6;
                padding: 20px;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                color: var(--accent-color);
            }

            .filter-block {
                background-color: var(--card-bg);
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .filter-block h2 {
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .button-group {
                display: flex;
                gap: 10px;
            }

            button {
                background-color: var(--button-bg);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: background-color 0.3s;
            }

            button:hover {
                background-color: var(--button-hover);
            }

            button.active {
                background-color: var(--accent-color);
            }

            .note {
                color: var(--muted-text);
                font-size: 12px;
                margin-top: 5px;
            }

            .important-note {
                color: var(--accent-color);
                font-size: 14px;
                margin: 10px 0;
                font-weight: bold;
                text-align: center;
            }

            .ranking-section {
                margin-top: 20px;
                background-color: var(--card-bg);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .ranking-title {
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 10px;
                color: var(--accent-color);
            }

            .ranking-list {
                list-style-type: none;
                padding: 0;
            }

            .ranking-item {
                display: flex;
                justify-content: space-between;
                padding: 8px;
                margin-bottom: 5px;
                border-radius: 4px;
                background-color: var(--table-row-odd);
            }

            .more-less-button {
                display: block;
                margin: 10px auto 0;
                background-color: var(--button-bg);
                color: white;
                border: none;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            }

            .more-less-button:hover {
                background-color: var(--button-hover);
            }

            .player-ranking-container {
                margin-top: 15px;
            }

            .ranking-section {
                margin-top: 20px;
                background-color: var(--card-bg);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .ranking-title {
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 10px;
                color: var(--accent-color);
            }

            .ranking-list {
                list-style-type: none;
                padding: 0;
            }

            .ranking-list li {
                display: flex;
                justify-content: space-between;
                padding: 5px 10px;
                border-bottom: 1px solid var(--border-color);
            }

            .more-less-button {
                background-color: transparent;
                color: var(--accent-color);
                border: 1px solid var(--accent-color);
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                margin-top: 10px;
                width: 100%;
                font-size: 12px;
            }

            .more-less-button:hover {
                background-color: rgba(187, 134, 252, 0.1);
            }

            .player-ranking-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px;
                border-radius: 4px;
            }

            .select-all-container {
                margin-bottom: 10px;
            }

            .hero-list {
                margin-top: 10px;
            }

            .hero-item {
                margin-bottom: 8px;
                padding: 5px;
                border-radius: 4px;
            }

            .hero-item:hover {
                background-color: var(--table-header);
            }

            .advanced-section {
                margin-bottom: 20px;
                padding: 10px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
            }

            .player-comparison {
                display: flex;
                flex-direction: column;
                gap: 20px;
                margin-top: 20px;
            }

            .comparison-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                background-color: var(--table-header);
                border-radius: 4px;
            }

            .player-card {
                flex: 1;
                padding: 15px;
                background-color: var(--card-bg);
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .player-hero {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
                padding: 8px;
                background-color: var(--table-row-odd);
                border-radius: 4px;
            }

            .player-hero-name {
                font-weight: bold;
                margin-right: 10px;
            }

            .player-hero-stats {
                margin-left: auto;
            }

            .head-to-head {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                background-color: var(--card-bg);
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
            }

            .head-to-head-score {
                font-size: 24px;
                font-weight: bold;
            }

            .player-name {
                font-size: 18px;
                font-weight: bold;
                color: var(--accent-color);
            }

            .match-history {
                margin-top: 20px;
            }

            .match-item {
                display: flex;
                justify-content: space-between;
                padding: 10px;
                border-bottom: 1px solid var(--border-color);
            }

            .match-item:last-child {
                border-bottom: none;
            }

            .match-result-win {
                color: var(--success-color);
                font-weight: bold;
            }

            .match-result-loss {
                color: var(--error-color);
                font-weight: bold;
            }

            .time-window,
            .patch-select,
            .tournament-select,
            .player-select,
            .opponent-select {
                display: none;
                margin-top: 15px;
            }

            .checkbox-list {
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid var(--border-color);
                padding: 10px;
                border-radius: 4px;
                margin-top: 10px;
            }

            .checkbox-item {
                margin-bottom: 8px;
            }

            label {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
            }

            input[type="checkbox"] {
                cursor: pointer;
            }

            input[type="date"],
            input[type="text"],
            select {
                width: 100%;
                padding: 8px;
                margin-top: 5px;
                border-radius: 4px;
                border: 1px solid var(--border-color);
                background-color: #333;
                color: var(--text-color);
            }

            .search-bar {
                margin-bottom: 15px;
            }

            .hero-grid {
                margin-top: 30px;
                overflow-x: auto;
            }

            table {
                border-collapse: collapse;
                width: 100%;
                min-width: 1000px;
            }

            th,
            td {
                padding: 10px;
                text-align: center;
                border: 1px solid var(--border-color);
            }

            th {
                background-color: var(--table-header);
                position: sticky;
                top: 0;
            }

            tr:nth-child(odd) {
                background-color: var(--table-row-odd);
            }

            tr:nth-child(even) {
                background-color: var(--table-row-even);
            }

            .hero-cell {
                font-weight: bold;
                background-color: var(--table-header);
            }

            .winrate-cell {
                transition: background-color 0.3s;
            }

            .stats-summary {
                margin-top: 20px;
                background-color: var(--card-bg);
                padding: 15px;
                border-radius: 8px;
            }

            .loading {
                text-align: center;
                padding: 20px;
                font-size: 18px;
                color: var(--accent-color);
            }

            .error {
                background-color: var(--error-color);
                color: white;
                padding: 10px;
                border-radius: 4px;
                margin-bottom: 15px;
            }

            .search-button-container {
                margin-top: 20px;
                text-align: center;
            }

            .search-button {
                padding: 10px 20px;
                font-size: 16px;
                background-color: var(--accent-color);
            }

            /* For mobile responsiveness */
            @media (max-width: 768px) {
                .button-group {
                    flex-direction: column;
                }

                .hero-grid {
                    overflow-x: scroll;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>PVZH Win Rate Browser</h1>
            <p class="important-note">
                Note: Win rates show Zombie (Win) vs Plants (Loss) statistics
            </p>

            <!-- Data/Patch Block -->
            <div class="filter-block">
                <h2>
                    <span>Data Selection</span>
                    <div class="button-group">
                        <button id="date-button">Date</button>
                        <button id="patch-button" class="active">Patch</button>
                    </div>
                </h2>
                <p class="note">
                    Results are sorted by time - newest games first
                </p>

                <div class="time-window" id="time-window">
                    <div class="date-range">
                        <label for="start-date">Start Date:</label>
                        <input type="date" id="start-date" />

                        <label for="end-date">End Date:</label>
                        <input type="date" id="end-date" />
                    </div>
                </div>

                <div class="patch-select" id="patch-select">
                    <div class="search-bar">
                        <input
                            type="text"
                            id="patch-search"
                            placeholder="Search patches..."
                        />
                    </div>
                    <div class="select-all-container">
                        <label>
                            <input type="checkbox" id="select-all-patches" />
                            Select/Deselect All
                        </label>
                        <p class="note">
                            If no patches are selected, data from all patches
                            will be used.
                        </p>
                    </div>
                    <div class="checkbox-list" id="patch-list">
                        <!-- Patches will be populated here -->
                        <div class="loading">Loading patches...</div>
                    </div>
                </div>
            </div>

            <!-- Tournament Block -->
            <div class="filter-block">
                <h2>Tournaments</h2>
                <div class="tournament-select" id="tournament-select">
                    <div class="search-bar">
                        <input
                            type="text"
                            id="tournament-search"
                            placeholder="Search tournaments..."
                        />
                    </div>
                    <div class="select-all-container">
                        <label>
                            <input
                                type="checkbox"
                                id="select-all-tournaments"
                            />
                            Select/Deselect All
                        </label>
                        <p class="note">
                            If no tournaments are selected, data from all
                            tournaments will be used.
                        </p>
                    </div>
                    <div class="checkbox-list" id="tournament-list">
                        <!-- Tournaments will be populated here -->
                        <div class="loading">Loading tournaments...</div>
                    </div>
                </div>
            </div>

            <!-- Player Block -->
            <div class="filter-block">
                <h2>
                    <span>Player Selection</span>
                    <div class="button-group">
                        <button id="players-button" class="active">
                            Players
                        </button>
                        <button id="opponent-button">Opponent</button>
                        <button id="teammate-button">Teammate</button>
                        <button id="advanced-button">Advanced</button>
                    </div>
                    <p class="important-note">
                        Note: Wins are for Zombie heroes and losses are for
                        Plant heroes
                    </p>
                </h2>

                <div class="player-select" id="player-select">
                    <div class="search-bar">
                        <input
                            type="text"
                            id="player-search"
                            placeholder="Search players..."
                        />
                    </div>
                    <div class="select-all-container">
                        <label>
                            <input type="checkbox" id="select-all-players" />
                            Select/Deselect All
                        </label>
                        <p class="note">
                            If no players are selected, data from all players
                            will be used.
                        </p>
                    </div>
                    <div class="checkbox-list" id="player-list">
                        <!-- Players will be populated here -->
                        <div class="loading">Loading players...</div>
                    </div>
                </div>

                <div class="opponent-select" id="opponent-select">
                    <div class="search-bar">
                        <input
                            type="text"
                            id="opponent-search"
                            placeholder="Search opponents..."
                        />
                        <div id="opponent-results" class="checkbox-list">
                            <!-- Opponent search results will be populated here -->
                        </div>
                    </div>
                    <div id="selected-opponent">
                        <!-- Selected opponent will be shown here -->
                    </div>
                    <div id="opponent-ranking-container" style="display: none">
                        <div class="ranking-section">
                            <div class="ranking-title">
                                Heroes This Opponent Loses Most To
                            </div>
                            <ul
                                id="opponent-weakness-ranking"
                                class="ranking-list"
                                data-visible="5"
                            ></ul>
                            <button
                                class="more-less-button"
                                id="opponent-weakness-more"
                            >
                                Show More
                            </button>
                        </div>
                        <div class="ranking-section">
                            <div class="ranking-title">Most Played Heroes</div>
                            <ul
                                id="opponent-most-played-ranking"
                                class="ranking-list"
                                data-visible="5"
                            ></ul>
                            <button
                                class="more-less-button"
                                id="opponent-played-more"
                            >
                                Show More
                            </button>
                        </div>
                    </div>
                </div>

                <div
                    class="teammate-select"
                    id="teammate-select"
                    style="display: none"
                >
                    <div class="search-bar">
                        <input
                            type="text"
                            id="teammate-search"
                            placeholder="Search teammates..."
                        />
                        <div id="teammate-results" class="checkbox-list">
                            <!-- Teammate search results will be populated here -->
                        </div>
                    </div>
                    <div id="selected-teammate">
                        <!-- Selected teammate will be shown here -->
                    </div>
                    <div id="teammate-ranking-container" style="display: none">
                        <div class="ranking-section">
                            <div class="ranking-title">Best Winrate Heroes</div>
                            <ul
                                id="teammate-best-winrate-ranking"
                                class="ranking-list"
                                data-visible="5"
                            ></ul>
                            <button
                                class="more-less-button"
                                id="teammate-winrate-more"
                            >
                                Show More
                            </button>
                        </div>
                        <div class="ranking-section">
                            <div class="ranking-title">Most Played Heroes</div>
                            <ul
                                id="teammate-most-played-ranking"
                                class="ranking-list"
                                data-visible="5"
                            ></ul>
                            <button
                                class="more-less-button"
                                id="teammate-played-more"
                            >
                                Show More
                            </button>
                        </div>
                    </div>
                </div>

                <div
                    class="advanced-select"
                    id="advanced-select"
                    style="display: none"
                >
                    <div class="advanced-section">
                        <h3>Player 1</h3>
                        <div class="search-bar">
                            <input
                                type="text"
                                id="advanced-player1-search"
                                placeholder="Search players..."
                            />
                            <div
                                id="advanced-player1-results"
                                class="checkbox-list"
                            >
                                <!-- Player 1 search results will be populated here -->
                            </div>
                        </div>
                        <div id="selected-player1">
                            <!-- Selected player 1 will be shown here -->
                        </div>
                    </div>

                    <div class="advanced-section">
                        <h3>Player 2</h3>
                        <div class="search-bar">
                            <input
                                type="text"
                                id="advanced-player2-search"
                                placeholder="Search players..."
                            />
                            <div
                                id="advanced-player2-results"
                                class="checkbox-list"
                            >
                                <!-- Player 2 search results will be populated here -->
                            </div>
                        </div>
                        <div id="selected-player2">
                            <!-- Selected player 2 will be shown here -->
                        </div>
                    </div>
                    <p class="note">
                        Select two players to see their head-to-head statistics.
                    </p>
                </div>
            </div>

            <div class="search-button-container">
                <button id="search-button" class="search-button">
                    Generate Win Rate Table
                </button>
            </div>

            <!-- Results Table -->
            <div class="hero-grid" id="hero-grid">
                <!-- Hero vs Hero grid will be generated here -->
            </div>

            <!-- Stats Summary -->
            <div class="stats-summary" id="stats-summary">
                <!-- Summary statistics will be displayed here -->
            </div>
        </div>

        <script>
            // Hero data
            const heroes = {
                zombies: [
                    "sb",
                    "sm",
                    "if",
                    "rb",
                    "eb",
                    "bf",
                    "pb",
                    "im",
                    "zm",
                    "nt",
                    "hg",
                ],
                plants: [
                    "gs",
                    "sf",
                    "wk",
                    "cz",
                    "sp",
                    "ct",
                    "gk",
                    "nc",
                    "ro",
                    "cc",
                    "bc",
                ],
            };

            // Hero display names (you can customize these)
            const heroNames = {
                sb: "Super Brainz",
                sm: "Smash",
                if: "Impfinity",
                rb: "Rustbolt",
                eb: "Electric Boogaloo",
                bf: "Brain Freeze",
                pb: "Professor Brainstorm",
                im: "Immorticia",
                zm: "Z-Mech",
                nt: "Neptuna",
                hg: "Huge-Gigantacus",
                gs: "Green Shadow",
                sf: "Solar Flare",
                wk: "Wall-Knight",
                cz: "Chompzilla",
                sp: "Spudow",
                ct: "Citron",
                gk: "Grass Knuckles",
                nc: "Nightcap",
                ro: "Rose",
                cc: "Captain Combustible",
                bc: "Beta-Carrotina",
            };

            // Global variables
            let allPatches = [];
            let allTournaments = [];
            let allPlayers = [];
            let matchData = [];

            // Element references
            const dateButton = document.getElementById("date-button");
            const patchButton = document.getElementById("patch-button");
            const timeWindow = document.getElementById("time-window");
            const patchSelect = document.getElementById("patch-select");
            const tournamentSelect =
                document.getElementById("tournament-select");
            const playersButton = document.getElementById("players-button");
            const opponentButton = document.getElementById("opponent-button");
            const teammateButton = document.getElementById("teammate-button");
            const playerSelect = document.getElementById("player-select");
            const opponentSelect = document.getElementById("opponent-select");
            const teammateSelect = document.getElementById("teammate-select");
            const searchButton = document.getElementById("search-button");
            const advancedButton = document.getElementById("advanced-button");

            // Initialize the page
            document.addEventListener("DOMContentLoaded", function () {
                // Show patch select by default
                patchSelect.style.display = "block";
                tournamentSelect.style.display = "block";
                playerSelect.style.display = "block";

                // Initialize teammate search
                document
                    .getElementById("teammate-search")
                    .addEventListener("input", function () {
                        searchTeammates();
                    });

                // Initial fetch of data
                fetchPatches();
                fetchPlayers();
                fetchTournaments();

                // Set default date range (last 30 days)
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);

                document.getElementById("end-date").valueAsDate = endDate;
                document.getElementById("start-date").valueAsDate = startDate;

                // Setup select all checkboxes
                document
                    .getElementById("select-all-patches")
                    .addEventListener("change", function () {
                        const checkboxes = document.querySelectorAll(
                            'input[name="patch"]',
                        );
                        checkboxes.forEach(
                            (checkbox) => (checkbox.checked = this.checked),
                        );
                        fetchTournaments();
                    });

                document
                    .getElementById("select-all-tournaments")
                    .addEventListener("change", function () {
                        const checkboxes = document.querySelectorAll(
                            'input[name="tournament"]',
                        );
                        checkboxes.forEach(
                            (checkbox) => (checkbox.checked = this.checked),
                        );
                    });

                document
                    .getElementById("select-all-players")
                    .addEventListener("change", function () {
                        const checkboxes = document.querySelectorAll(
                            'input[name="player"]',
                        );
                        checkboxes.forEach(
                            (checkbox) => (checkbox.checked = this.checked),
                        );
                    });
            });

            // Toggle between date and patch selection
            dateButton.addEventListener("click", function () {
                dateButton.classList.add("active");
                patchButton.classList.remove("active");
                timeWindow.style.display = "block";
                patchSelect.style.display = "none";
            });

            patchButton.addEventListener("click", function () {
                patchButton.classList.add("active");
                dateButton.classList.remove("active");
                patchSelect.style.display = "block";
                timeWindow.style.display = "none";
            });

            // Toggle between players, opponent, teammate, and advanced selection
            playersButton.addEventListener("click", function () {
                playersButton.classList.add("active");
                opponentButton.classList.remove("active");
                teammateButton.classList.remove("active");
                document
                    .getElementById("advanced-button")
                    .classList.remove("active");
                playerSelect.style.display = "block";
                opponentSelect.style.display = "none";
                teammateSelect.style.display = "none";
                document.getElementById("advanced-select").style.display =
                    "none";
            });

            opponentButton.addEventListener("click", function () {
                opponentButton.classList.add("active");
                playersButton.classList.remove("active");
                teammateButton.classList.remove("active");
                document
                    .getElementById("advanced-button")
                    .classList.remove("active");
                opponentSelect.style.display = "block";
                playerSelect.style.display = "none";
                teammateSelect.style.display = "none";
                document.getElementById("advanced-select").style.display =
                    "none";
            });

            teammateButton.addEventListener("click", function () {
                teammateButton.classList.add("active");
                opponentButton.classList.remove("active");
                playersButton.classList.remove("active");
                document
                    .getElementById("advanced-button")
                    .classList.remove("active");
                teammateSelect.style.display = "block";
                opponentSelect.style.display = "none";
                playerSelect.style.display = "none";
                document.getElementById("advanced-select").style.display =
                    "none";
            });

            document
                .getElementById("advanced-button")
                .addEventListener("click", function () {
                    this.classList.add("active");
                    playersButton.classList.remove("active");
                    opponentButton.classList.remove("active");
                    teammateButton.classList.remove("active");
                    document.getElementById("advanced-select").style.display =
                        "block";
                    playerSelect.style.display = "none";
                    opponentSelect.style.display = "none";
                    teammateSelect.style.display = "none";
                });

            // Handle More/Less buttons for rankings
            document.addEventListener("click", function (e) {
                if (
                    e.target &&
                    e.target.classList.contains("more-less-button")
                ) {
                    const button = e.target;
                    const listId = button.id
                        .replace("-more", "")
                        .replace("-less", "");
                    const list = document.getElementById(listId + "-ranking");

                    if (list) {
                        const isShowingAll = button.textContent === "Show Less";
                        const visibleItems = isShowingAll ? 5 : 999;

                        // Update list data attribute
                        list.setAttribute("data-visible", visibleItems);

                        // Show/hide items based on the setting
                        const items = list.querySelectorAll("li");
                        items.forEach((item, index) => {
                            if (index < visibleItems) {
                                item.style.display = "";
                            } else {
                                item.style.display = "none";
                            }
                        });

                        // Update button text
                        button.textContent = isShowingAll
                            ? "Show More"
                            : "Show Less";
                        button.id = listId + (isShowingAll ? "-more" : "-less");
                    }
                }
            });

            // Search functionality
            document
                .getElementById("patch-search")
                .addEventListener("input", (e) => {
                    filterCheckboxList("patch-list", e.target.value);
                });

            document
                .getElementById("tournament-search")
                .addEventListener("input", (e) => {
                    filterCheckboxList("tournament-list", e.target.value);
                });

            document
                .getElementById("player-search")
                .addEventListener("input", (e) => {
                    filterCheckboxList("player-list", e.target.value);
                });

            document
                .getElementById("opponent-search")
                .addEventListener("input", (e) => {
                    searchOpponents(e.target.value);
                });

            // Filter checkbox list based on search input
            function filterCheckboxList(listId, query) {
                const list = document.getElementById(listId);
                const items = list.getElementsByClassName("checkbox-item");

                for (let i = 0; i < items.length; i++) {
                    const label = items[i].querySelector("label");
                    if (
                        label.textContent
                            .toLowerCase()
                            .includes(query.toLowerCase())
                    ) {
                        items[i].style.display = "";
                    } else {
                        items[i].style.display = "none";
                    }
                }
            }

            // Search opponents
            function searchOpponents(query) {
                if (query.length < 2) {
                    document.getElementById("opponent-results").innerHTML = "";
                    return;
                }

                const matchingPlayers = allPlayers.filter((player) =>
                    player.toLowerCase().includes(query.toLowerCase()),
                );

                const resultsHtml = matchingPlayers
                    .map(
                        (player) =>
                            `<div class="checkbox-item">
                    <label>${player}</label>
                    <button class="select-opponent" data-player="${player}">Select</button>
                </div>`,
                    )
                    .join("");

                document.getElementById("opponent-results").innerHTML =
                    resultsHtml;

                // Add event listeners to select buttons
                document
                    .querySelectorAll(".select-opponent")
                    .forEach((button) => {
                        button.addEventListener("click", () => {
                            selectOpponent(button.dataset.player);
                        });
                    });
            }

            // Select an opponent
            function selectOpponent(player) {
                document.getElementById("selected-opponent").innerHTML =
                    `<div class="selected-player">
                    <h3>Selected Opponent: ${player}</h3>
                    <button id="clear-opponent">Clear</button>
                </div>`;

                document.getElementById("opponent-search").value = "";
                document.getElementById("opponent-results").innerHTML = "";

                document
                    .getElementById("clear-opponent")
                    .addEventListener("click", () => {
                        document.getElementById("selected-opponent").innerHTML =
                            "";
                    });
            }

            // Fetch patches
            async function fetchPatches() {
                try {
                    // Get list of directories in the datafiles folder
                    const repoOwner = "Zintrall";
                    const repoName = "zintrall.github.io";
                    const path = "datafiles";

                    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error("Failed to fetch patches");
                    }

                    const data = await response.json();
                    allPatches = data
                        .filter((item) => item.type === "dir")
                        .map((item) => item.name);

                    renderPatchList();
                    fetchTournaments();
                } catch (error) {
                    console.error("Error fetching patches:", error);
                    // Fallback to dummy data if fetch fails
                    allPatches = [
                        "patch_1.0",
                        "patch_1.1",
                        "patch_2.0",
                        "patch_2.1",
                        "patch_3.0",
                    ];
                    renderPatchList();
                    fetchTournaments();
                }
            }

            // Render patch list
            function renderPatchList() {
                const patchList = document.getElementById("patch-list");
                patchList.innerHTML = allPatches
                    .map(
                        (patch) =>
                            `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="patch" value="${patch}">
                        ${patch}
                    </label>
                </div>`,
                    )
                    .join("");

                // When patches are selected, update tournament list
                document
                    .querySelectorAll('input[name="patch"]')
                    .forEach((checkbox) => {
                        checkbox.addEventListener("change", fetchTournaments);
                    });
            }

            // Fetch tournaments based on selected patches
            async function fetchTournaments() {
                const selectedPatches = Array.from(
                    document.querySelectorAll('input[name="patch"]:checked'),
                ).map((input) => input.value);

                document.getElementById("tournament-list").innerHTML =
                    '<div class="loading">Loading tournaments...</div>';

                document.getElementById("tournament-list").innerHTML =
                    '<div class="loading">Loading tournaments...</div>';

                try {
                    const repoOwner = "Zintrall";
                    const repoName = "zintrall.github.io";

                    let allTournamentsData = [];

                    // Fetch tournaments for each selected patch
                    for (const patch of selectedPatches) {
                        const path = `datafiles/${patch}`;
                        const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;

                        try {
                            const response = await fetch(apiUrl);

                            if (response.ok) {
                                const data = await response.json();
                                const tournaments = data
                                    .filter(
                                        (item) =>
                                            item.type === "file" &&
                                            item.name.endsWith(".txt"),
                                    )
                                    .map((item) => ({
                                        name: item.name.replace(".txt", ""),
                                        patch: patch,
                                        fullName: `${patch}/${item.name}`,
                                    }));

                                allTournamentsData =
                                    allTournamentsData.concat(tournaments);
                            }
                        } catch (error) {
                            console.error(
                                `Error fetching tournaments for patch ${patch}:`,
                                error,
                            );
                        }
                    }

                    allTournaments = allTournamentsData;
                    renderTournamentList();
                } catch (error) {
                    console.error("Error fetching tournaments:", error);
                    // Fallback to dummy data if fetch fails
                    allTournaments = generateDummyTournaments(selectedPatches);
                    renderTournamentList();
                }
            }

            // Generate dummy tournaments (fallback if GitHub API fails)
            function generateDummyTournaments(patches) {
                const tournaments = [];
                patches.forEach((patch) => {
                    const count = Math.floor(Math.random() * 5) + 1;
                    for (let i = 1; i <= count; i++) {
                        tournaments.push({
                            name: `tournament_${i}`,
                            patch: patch,
                            fullName: `${patch}/tournament_${i}.txt`,
                        });
                    }
                });
                return tournaments;
            }

            // Render tournament list
            function renderTournamentList() {
                const tournamentList =
                    document.getElementById("tournament-list");
                if (allTournaments.length === 0) {
                    tournamentList.innerHTML =
                        '<div class="error">No tournaments found for the selected patches</div>';
                    return;
                }

                tournamentList.innerHTML = allTournaments
                    .map(
                        (tournament) =>
                            `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="tournament" value="${tournament.fullName}" data-patch="${tournament.patch}" checked>
                        ${tournament.name} (${tournament.patch})
                    </label>
                </div>`,
                    )
                    .join("");
            }

            // Fetch players
            async function fetchPlayers() {
                try {
                    const repoOwner = "Zintrall";
                    const repoName = "zintrall.github.io";
                    const filePath = "playernames.txt";

                    const apiUrl = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/${filePath}`;
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error("Failed to fetch player names");
                    }

                    const data = await response.text();
                    allPlayers = data
                        .split("\n")
                        .filter((name) => name.trim() !== "");
                    renderPlayerList();
                } catch (error) {
                    console.error("Error fetching players:", error);
                    // Fallback to dummy data if fetch fails
                    allPlayers = [
                        "Player1",
                        "Player2",
                        "Player3",
                        "Player4",
                        "Player5",
                        "Player6",
                        "Player7",
                        "Player8",
                        "Player9",
                        "Player10",
                    ];
                    renderPlayerList();
                }
            }

            // Render player list
            function renderPlayerList() {
                const playerList = document.getElementById("player-list");
                playerList.innerHTML = allPlayers
                    .map(
                        (player) =>
                            `<div class="checkbox-item">
                    <label>
                        <input type="checkbox" name="player" value="${player}">
                        ${player}
                    </label>
                </div>`,
                    )
                    .join("");

                // Setup advanced mode player search
                document
                    .getElementById("advanced-player1-search")
                    .addEventListener("input", (e) => {
                        searchAdvancedPlayer(e.target.value, "1");
                    });

                document
                    .getElementById("advanced-player2-search")
                    .addEventListener("input", (e) => {
                        searchAdvancedPlayer(e.target.value, "2");
                    });
            }

            // Search players for advanced mode
            function searchAdvancedPlayer(query, playerNum) {
                if (query.length < 2) {
                    document.getElementById(
                        `advanced-player${playerNum}-results`,
                    ).innerHTML = "";
                    return;
                }

                const matchingPlayers = allPlayers.filter((player) =>
                    player.toLowerCase().includes(query.toLowerCase()),
                );

                const resultsHtml = matchingPlayers
                    .map(
                        (player) =>
                            `<div class="checkbox-item">
                    <label>${player}</label>
                    <button class="select-advanced-player" data-player="${player}" data-num="${playerNum}">Select</button>
                </div>`,
                    )
                    .join("");

                document.getElementById(
                    `advanced-player${playerNum}-results`,
                ).innerHTML = resultsHtml;

                // Add event listeners to select buttons
                document
                    .querySelectorAll(
                        `.select-advanced-player[data-num="${playerNum}"]`,
                    )
                    .forEach((button) => {
                        button.addEventListener("click", () => {
                            selectAdvancedPlayer(
                                button.dataset.player,
                                playerNum,
                            );
                        });
                    });
            }

            // Select a player in advanced mode
            function selectAdvancedPlayer(player, playerNum) {
                document.getElementById(
                    `selected-player${playerNum}`,
                ).innerHTML = `<div class="selected-player">
                    <h3>Selected Player ${playerNum}: ${player}</h3>
                    <button class="clear-player" data-num="${playerNum}">Clear</button>
                </div>`;

                document.getElementById(
                    `advanced-player${playerNum}-search`,
                ).value = "";
                document.getElementById(
                    `advanced-player${playerNum}-results`,
                ).innerHTML = "";

                document
                    .querySelector(`.clear-player[data-num="${playerNum}"]`)
                    .addEventListener("click", () => {
                        document.getElementById(
                            `selected-player${playerNum}`,
                        ).innerHTML = "";
                    });
            }

            // Generate win rate table
            searchButton.addEventListener("click", generateWinRateTable);

            function generateWinRateTable() {
                const heroGrid = document.getElementById("hero-grid");
                heroGrid.innerHTML =
                    '<div class="loading">Generating win rate table...</div>';

                // In a real implementation, this would fetch and process your data
                // For now, we'll simulate with dummy data
                setTimeout(() => {
                    fetchMatchData();
                }, 1000);
            }

            // Fetch match data
            async function fetchMatchData() {
                const heroGrid = document.getElementById("hero-grid");
                const statsSummary = document.getElementById("stats-summary");

                heroGrid.innerHTML =
                    '<div class="loading">Loading match data...</div>';
                statsSummary.innerHTML = "";

                // Determine date range or patches
                let dataFilter;
                if (dateButton.classList.contains("active")) {
                    dataFilter = {
                        type: "date",
                        startDate: document.getElementById("start-date").value,
                        endDate: document.getElementById("end-date").value,
                    };
                } else {
                    const selectedPatches = Array.from(
                        document.querySelectorAll(
                            'input[name="patch"]:checked',
                        ),
                    ).map((input) => input.value);

                    dataFilter = {
                        type: "patch",
                        patches: selectedPatches,
                        allPatches: selectedPatches.length === 0, // Flag to indicate all patches should be used
                    };
                }

                // Get selected tournaments
                const selectedTournaments = Array.from(
                    document.querySelectorAll(
                        'input[name="tournament"]:checked',
                    ),
                ).map((input) => input.value);

                const useAllTournaments = selectedTournaments.length === 0;

                // Get player filter type and selection
                let playerFilter;
                if (
                    document
                        .getElementById("advanced-button")
                        .classList.contains("active")
                ) {
                    // Advanced mode: player 1 vs player 2
                    const player1El =
                        document.getElementById("selected-player1");
                    const player2El =
                        document.getElementById("selected-player2");

                    const player1 = player1El.textContent.trim()
                        ? player1El.textContent
                              .replace("Selected Player 1:", "")
                              .replace("Clear", "")
                              .trim()
                        : null;
                    const player2 = player2El.textContent.trim()
                        ? player2El.textContent
                              .replace("Selected Player 2:", "")
                              .replace("Clear", "")
                              .trim()
                        : null;

                    playerFilter = {
                        type: "advanced",
                        player1: player1,
                        player2: player2,
                    };
                } else if (playersButton.classList.contains("active")) {
                    const selectedPlayers = Array.from(
                        document.querySelectorAll(
                            'input[name="player"]:checked',
                        ),
                    ).map((input) => input.value);

                    playerFilter = {
                        type: "players",
                        players: selectedPlayers,
                        allPlayers: selectedPlayers.length === 0, // Flag to indicate all players should be used
                    };
                } else {
                    const selectedOpponent = document
                        .getElementById("selected-opponent")
                        .textContent.trim();
                    playerFilter = {
                        type: "opponent",
                        opponent: selectedOpponent
                            ? selectedOpponent
                                  .replace("Selected Opponent: ", "")
                                  .replace("Clear", "")
                                  .trim()
                            : null,
                    };
                }

                try {
                    // Fetch real match data from GitHub repository
                    const matchResults = await fetchRealMatchData(
                        dataFilter,
                        selectedTournaments,
                        playerFilter,
                        useAllTournaments,
                    );

                    if (matchResults.length === 0) {
                        heroGrid.innerHTML =
                            '<div class="error">No match data found with the current filters</div>';
                        statsSummary.innerHTML = "";
                        return;
                    }

                    matchData = matchResults;

                    // For advanced mode, show special head-to-head comparison
                    if (
                        playerFilter.type === "advanced" &&
                        playerFilter.player1 &&
                        playerFilter.player2
                    ) {
                        renderAdvancedComparison(
                            matchData,
                            playerFilter.player1,
                            playerFilter.player2,
                        );
                    } else {
                        renderWinRateTable(matchData);
                        renderStatsSummary(matchData);
                    }
                } catch (error) {
                    console.error("Error fetching match data:", error);
                    heroGrid.innerHTML = `<div class="error">Error loading data: ${error.message}</div>`;

                    // Fallback to dummy data for demo purposes
                    matchData = generateDummyMatchData();
                    renderWinRateTable(matchData);
                    renderStatsSummary(matchData);
                }
            }

            // Generate dummy match data (replace with actual data fetching)
            function generateDummyMatchData() {
                const data = [];

                // Create a data structure to hold the match results
                // This would normally be populated from your text files

                // Generate some dummy data for every hero combination
                heroes.zombies.forEach((zombie) => {
                    heroes.plants.forEach((plant) => {
                        // Random win count between 0 and 100
                        const zombieWins = Math.floor(Math.random() * 100);
                        const plantWins = Math.floor(Math.random() * 100);

                        data.push({
                            zombie,
                            plant,
                            zombieWins,
                            plantWins,
                            totalMatches: zombieWins + plantWins,
                            zombieWinRate:
                                zombieWins / (zombieWins + plantWins),
                        });
                    });
                });

                return data;
            }

            // Render win rate table
            function renderWinRateTable(data) {
                const heroGrid = document.getElementById("hero-grid");

                // Create table
                let tableHtml = "<table>";

                // Header row with plant heroes
                tableHtml += "<tr><th></th>"; // Empty corner cell
                heroes.plants.forEach((plant) => {
                    tableHtml += `<th title="${heroNames[plant]}">${plant.toUpperCase()}</th>`;
                });
                tableHtml += "<th>Total</th></tr>";

                // Create a row for each zombie hero
                heroes.zombies.forEach((zombie) => {
                    tableHtml += `<tr><td class="hero-cell" title="${heroNames[zombie]}">${zombie.toUpperCase()}</td>`;

                    let totalMatches = 0;
                    let totalWins = 0;

                    // Create a cell for each plant vs zombie matchup
                    heroes.plants.forEach((plant) => {
                        const matchup = data.find(
                            (m) => m.zombie === zombie && m.plant === plant,
                        );

                        if (matchup) {
                            totalMatches += matchup.totalMatches;
                            totalWins += matchup.zombieWins;

                            const winRate = matchup.zombieWinRate;
                            const winRatePercent =
                                (winRate * 100).toFixed(1) + "%";
                            const matches = matchup.totalMatches;

                            // Color coding
                            let bgColor = getWinRateColor(winRate);

                            tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${matches} games">
                            ${winRatePercent}<br><small>(${matches})</small>
                        </td>`;
                        } else {
                            tableHtml += '<td class="winrate-cell">N/A</td>';
                        }
                    });

                    // Add total column
                    const overallWinRate =
                        totalMatches > 0 ? totalWins / totalMatches : 0;
                    const overallWinRatePercent =
                        (overallWinRate * 100).toFixed(1) + "%";
                    const bgColor = getWinRateColor(overallWinRate);

                    tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${totalMatches} games">
                    ${overallWinRatePercent}<br><small>(${totalMatches})</small>
                </td>`;

                    tableHtml += "</tr>";
                });

                // Add a total row for plants
                tableHtml += '<tr><td class="hero-cell">Total</td>';

                heroes.plants.forEach((plant) => {
                    const plantMatches = data.filter((m) => m.plant === plant);
                    const totalMatches = plantMatches.reduce(
                        (sum, m) => sum + m.totalMatches,
                        0,
                    );
                    const plantWins = plantMatches.reduce(
                        (sum, m) => sum + m.plantWins,
                        0,
                    );
                    const plantWinRate =
                        totalMatches > 0 ? plantWins / totalMatches : 0;
                    const plantWinRatePercent =
                        (plantWinRate * 100).toFixed(1) + "%";
                    const bgColor = getWinRateColor(1 - plantWinRate); // Invert since this is from zombie perspective

                    tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${totalMatches} games">
                    ${plantWinRatePercent}<br><small>(${totalMatches})</small>
                </td>`;
                });

                // Overall total
                const allMatches = data.reduce(
                    (sum, m) => sum + m.totalMatches,
                    0,
                );
                const allZombieWins = data.reduce(
                    (sum, m) => sum + m.zombieWins,
                    0,
                );
                const overallZombieWinRate =
                    allMatches > 0 ? allZombieWins / allMatches : 0;
                const overallZombieWinRatePercent =
                    (overallZombieWinRate * 100).toFixed(1) + "%";
                const bgColor = getWinRateColor(overallZombieWinRate);

                tableHtml += `<td class="winrate-cell" style="background-color: ${bgColor};" title="${allMatches} games">
                ${overallZombieWinRatePercent}<br><small>(${allMatches})</small>
            </td>`;

                tableHtml += "</tr>";
                tableHtml += "</table>";

                heroGrid.innerHTML = tableHtml;
            }

            // Get color for win rate cell - each percentage point gets a different color
            function getWinRateColor(winRate) {
                // Convert winRate to percentage value
                const percentage = winRate * 100;
                const percentageFixed = percentage.toFixed(1);

                // Create a unique color for each percentage point to ensure different colors
                if (percentage < 35) {
                    // Red for < 35%
                    // Small variance for each decimal to ensure different colors
                    const variant =
                        parseFloat("0." + percentageFixed.replace(".", "")) *
                        30;
                    return `rgb(255, ${Math.floor(variant)}, 0)`;
                } else if (percentage < 45) {
                    // Orange for 35-45%
                    const variant =
                        (percentage - 35) * 10 +
                        parseFloat("0." + percentageFixed.replace(".", "")) * 5;
                    return `rgb(255, ${Math.floor(130 + variant)}, 0)`;
                } else if (percentage < 55) {
                    // Yellow for 45-55%
                    const variant =
                        (percentage - 45) * 10 +
                        parseFloat("0." + percentageFixed.replace(".", "")) * 5;
                    return `rgb(${Math.floor(255 - variant)}, 255, ${Math.floor(variant)})`;
                } else if (percentage < 65) {
                    // Light green for 55-65%
                    const variant =
                        (percentage - 55) * 10 +
                        parseFloat("0." + percentageFixed.replace(".", "")) * 5;
                    return `rgb(${Math.floor(variant)}, 220, ${Math.floor(variant)})`;
                } else {
                    // Dark green for 65%+
                    const variant =
                        (percentage - 65) * 3 +
                        parseFloat("0." + percentageFixed.replace(".", "")) * 3;
                    return `rgb(0, ${Math.floor(128 + variant)}, 0)`;
                }
            }

            // Render opponent rankings
            function renderOpponentRankings(opponentId) {
                const opponent = allPlayers.find((p) => p.id === opponentId);
                if (!opponent || !matchData.length) return;

                // Filter matches involving this opponent
                const opponentMatches = matchData.filter(
                    (match) =>
                        match.player2Id === opponentId ||
                        match.player1Id === opponentId,
                );

                // Get opponent losses data (when opponent is on plants side)
                const opponentLosses = {};
                const opponentPlayed = {};

                opponentMatches.forEach((match) => {
                    // Opponent playing as plants (P2)
                    if (match.player2Id === opponentId) {
                        if (!opponentLosses[match.hero1]) {
                            opponentLosses[match.hero1] = {
                                wins: 0,
                                losses: 0,
                            };
                        }
                        if (!opponentPlayed[match.hero2]) {
                            opponentPlayed[match.hero2] = { count: 0 };
                        }
                        if (match.winner === "hero1") {
                            opponentLosses[match.hero1].wins++;
                        } else {
                            opponentLosses[match.hero1].losses++;
                        }
                        opponentPlayed[match.hero2].count++;
                    }

                    // Opponent playing as zombies (P1)
                    if (match.player1Id === opponentId) {
                        if (!opponentLosses[match.hero2]) {
                            opponentLosses[match.hero2] = {
                                wins: 0,
                                losses: 0,
                            };
                        }
                        if (!opponentPlayed[match.hero1]) {
                            opponentPlayed[match.hero1] = { count: 0 };
                        }
                        if (match.winner === "hero2") {
                            opponentLosses[match.hero2].wins++;
                        } else {
                            opponentLosses[match.hero2].losses++;
                        }
                        opponentPlayed[match.hero1].count++;
                    }
                });

                // Calculate win rates for heroes against this opponent
                const heroLossData = Object.keys(opponentLosses).map((hero) => {
                    const data = opponentLosses[hero];
                    const winRate = data.wins / (data.wins + data.losses);
                    return {
                        hero: hero,
                        heroName: heroNames[hero] || hero,
                        games: data.wins + data.losses,
                        winRate: winRate,
                    };
                });

                // Sort by win rate
                heroLossData.sort((a, b) => b.winRate - a.winRate);

                // Get most played heroes
                const mostPlayedData = Object.keys(opponentPlayed).map(
                    (hero) => {
                        return {
                            hero: hero,
                            heroName: heroNames[hero] || hero,
                            count: opponentPlayed[hero].count,
                        };
                    },
                );

                // Sort by count
                mostPlayedData.sort((a, b) => b.count - a.count);

                // Render the rankings
                const weaknessContainer = document.getElementById(
                    "opponent-weakness-ranking",
                );
                const playedContainer = document.getElementById(
                    "opponent-most-played-ranking",
                );
                weaknessContainer.innerHTML = "";
                playedContainer.innerHTML = "";

                // Render top heroes that beat this opponent
                heroLossData.slice(0, 15).forEach((heroData) => {
                    const li = document.createElement("li");
                    li.className = "ranking-item";
                    li.innerHTML = `
                    <span class="hero-name">${heroData.heroName}</span>
                    <span class="win-rate" style="color: ${getWinRateColor(heroData.winRate)}">
                        ${(heroData.winRate * 100).toFixed(1)}% (${heroData.games} games)
                    </span>
                `;
                    weaknessContainer.appendChild(li);
                });

                // Render most played heroes
                mostPlayedData.slice(0, 15).forEach((heroData) => {
                    const li = document.createElement("li");
                    li.className = "ranking-item";
                    li.innerHTML = `
                    <span class="hero-name">${heroData.heroName}</span>
                    <span class="games-played">${heroData.count} games</span>
                `;
                    playedContainer.appendChild(li);
                });

                // Show the ranking container
                document.getElementById(
                    "opponent-ranking-container",
                ).style.display = "block";

                // Show only first 5 items initially
                const weaknessItems = weaknessContainer.querySelectorAll("li");
                const playedItems = playedContainer.querySelectorAll("li");

                weaknessItems.forEach((item, index) => {
                    if (index >= 5) item.style.display = "none";
                });

                playedItems.forEach((item, index) => {
                    if (index >= 5) item.style.display = "none";
                });

                // Set up More/Less buttons
                document.getElementById("opponent-weakness-more").textContent =
                    "Show More";
                document.getElementById("opponent-played-more").textContent =
                    "Show More";
            }

            // Render teammate rankings
            function renderTeammateRankings(teammateId) {
                const teammate = allPlayers.find((p) => p.id === teammateId);
                if (!teammate || !matchData.length) return;

                // Filter matches involving this teammate
                const teammateMatches = matchData.filter(
                    (match) =>
                        match.player2Id === teammateId ||
                        match.player1Id === teammateId,
                );

                // Get teammate win rate data by hero
                const teammateHeroes = {};

                teammateMatches.forEach((match) => {
                    // Teammate playing as zombies (P1)
                    if (match.player1Id === teammateId) {
                        if (!teammateHeroes[match.hero1]) {
                            teammateHeroes[match.hero1] = {
                                wins: 0,
                                losses: 0,
                            };
                        }
                        if (match.winner === "hero1") {
                            teammateHeroes[match.hero1].wins++;
                        } else {
                            teammateHeroes[match.hero1].losses++;
                        }
                    }

                    // Teammate playing as plants (P2)
                    if (match.player2Id === teammateId) {
                        if (!teammateHeroes[match.hero2]) {
                            teammateHeroes[match.hero2] = {
                                wins: 0,
                                losses: 0,
                            };
                        }
                        if (match.winner === "hero2") {
                            teammateHeroes[match.hero2].wins++;
                        } else {
                            teammateHeroes[match.hero2].losses++;
                        }
                    }
                });

                // Calculate win rates for heroes
                const heroWinRateData = Object.keys(teammateHeroes).map(
                    (hero) => {
                        const data = teammateHeroes[hero];
                        const winRate = data.wins / (data.wins + data.losses);
                        return {
                            hero: hero,
                            heroName: heroNames[hero] || hero,
                            games: data.wins + data.losses,
                            wins: data.wins,
                            losses: data.losses,
                            winRate: winRate,
                        };
                    },
                );

                // Sort by win rate and games played
                const byWinRate = [...heroWinRateData].sort(
                    (a, b) => b.winRate - a.winRate,
                );
                const byGamesPlayed = [...heroWinRateData].sort(
                    (a, b) => b.games - a.games,
                );

                // Render the rankings
                const winRateContainer = document.getElementById(
                    "teammate-best-winrate-ranking",
                );
                const playedContainer = document.getElementById(
                    "teammate-most-played-ranking",
                );
                winRateContainer.innerHTML = "";
                playedContainer.innerHTML = "";

                // Render top heroes by win rate
                byWinRate.slice(0, 15).forEach((heroData) => {
                    const li = document.createElement("li");
                    li.className = "ranking-item";
                    li.innerHTML = `
                    <span class="hero-name">${heroData.heroName}</span>
                    <span class="win-rate" style="color: ${getWinRateColor(heroData.winRate)}">
                        ${(heroData.winRate * 100).toFixed(1)}% (${heroData.wins}-${heroData.losses})
                    </span>
                `;
                    winRateContainer.appendChild(li);
                });

                // Render most played heroes
                byGamesPlayed.slice(0, 15).forEach((heroData) => {
                    const li = document.createElement("li");
                    li.className = "ranking-item";
                    li.innerHTML = `
                    <span class="hero-name">${heroData.heroName}</span>
                    <span class="games-played">${heroData.games} games (${(heroData.winRate * 100).toFixed(1)}%)</span>
                `;
                    playedContainer.appendChild(li);
                });

                // Show the ranking container
                document.getElementById(
                    "teammate-ranking-container",
                ).style.display = "block";

                // Show only first 5 items initially
                const winrateItems = winRateContainer.querySelectorAll("li");
                const playedItems = playedContainer.querySelectorAll("li");

                winrateItems.forEach((item, index) => {
                    if (index >= 5) item.style.display = "none";
                });

                playedItems.forEach((item, index) => {
                    if (index >= 5) item.style.display = "none";
                });

                // Set up More/Less buttons
                document.getElementById("teammate-winrate-more").textContent =
                    "Show More";
                document.getElementById("teammate-played-more").textContent =
                    "Show More";
            }

            // Handle More/Less buttons for rankings
            function setupMoreLessButtons() {
                document
                    .querySelectorAll(".more-less-button")
                    .forEach((button) => {
                        button.addEventListener("click", function () {
                            const listId = this.id
                                .replace("-more", "")
                                .replace("-less", "");
                            const list = document.getElementById(
                                listId + "-ranking",
                            );
                            const isShowingMore =
                                this.textContent === "Show Less";

                            const items = list.querySelectorAll("li");
                            const defaultVisible = parseInt(
                                list.getAttribute("data-visible"),
                            );

                            if (isShowingMore) {
                                // Switch to showing fewer
                                for (
                                    let i = defaultVisible;
                                    i < items.length;
                                    i++
                                ) {
                                    items[i].style.display = "none";
                                }
                                this.textContent = "Show More";
                            } else {
                                // Show all
                                items.forEach(
                                    (item) => (item.style.display = "flex"),
                                );
                                this.textContent = "Show Less";
                            }
                        });
                    });
            }

            // Render stats summary
            function renderStatsSummary(data) {
                const statsSummary = document.getElementById("stats-summary");

                // Calculate most played heroes
                const heroPlayCount = {};

                heroes.zombies.forEach((zombie) => {
                    heroPlayCount[zombie] = data
                        .filter((m) => m.zombie === zombie)
                        .reduce((sum, m) => sum + m.totalMatches, 0);
                });

                heroes.plants.forEach((plant) => {
                    heroPlayCount[plant] = data
                        .filter((m) => m.plant === plant)
                        .reduce((sum, m) => sum + m.totalMatches, 0);
                });

                // Sort heroes by play count
                const sortedHeroes = Object.entries(heroPlayCount)
                    .sort((a, b) => b[1] - a[1])
                    .map(([hero, count]) => ({
                        hero,
                        count,
                        type: heroes.zombies.includes(hero)
                            ? "Zombie"
                            : "Plant",
                    }));

                let summaryHtml = "<h2>Hero Play Stats</h2>";

                // Most played heroes
                summaryHtml +=
                    '<div class="stats-section"><h3>Most Played Heroes</h3><div class="hero-list">';
                sortedHeroes.slice(0, 5).forEach((item) => {
                    summaryHtml += `<div class="hero-item">${heroNames[item.hero]} (${item.type}): ${item.count} games</div>`;
                });
                summaryHtml += "</div></div>";

                // Best performing heroes (by win rate)
                const zombieHeroStats = heroes.zombies
                    .map((zombie) => {
                        const matches = data.filter((m) => m.zombie === zombie);
                        const totalMatches = matches.reduce(
                            (sum, m) => sum + m.totalMatches,
                            0,
                        );
                        const wins = matches.reduce(
                            (sum, m) => sum + m.zombieWins,
                            0,
                        );
                        const winRate =
                            totalMatches > 0 ? wins / totalMatches : 0;
                        return { hero: zombie, winRate, matches: totalMatches };
                    })
                    .filter((h) => h.matches > 0);

                const plantHeroStats = heroes.plants
                    .map((plant) => {
                        const matches = data.filter((m) => m.plant === plant);
                        const totalMatches = matches.reduce(
                            (sum, m) => sum + m.totalMatches,
                            0,
                        );
                        const wins = matches.reduce(
                            (sum, m) => sum + m.plantWins,
                            0,
                        );
                        const winRate =
                            totalMatches > 0 ? wins / totalMatches : 0;
                        return { hero: plant, winRate, matches: totalMatches };
                    })
                    .filter((h) => h.matches > 0);

                // Best zombie heroes
                const bestZombies = [...zombieHeroStats].sort(
                    (a, b) => b.winRate - a.winRate,
                );

                summaryHtml +=
                    '<div class="stats-section"><h3>Best Performing Zombie Heroes</h3><div class="hero-list">';
                bestZombies.slice(0, 3).forEach((item) => {
                    const winRatePercent =
                        (item.winRate * 100).toFixed(1) + "%";
                    summaryHtml += `<div class="hero-item">${heroNames[item.hero]}: ${winRatePercent} win rate (${item.matches} games)</div>`;
                });
                summaryHtml += "</div></div>";

                // Best plant heroes
                const bestPlants = [...plantHeroStats].sort(
                    (a, b) => b.winRate - a.winRate,
                );

                summaryHtml +=
                    '<div class="stats-section"><h3>Best Performing Plant Heroes</h3><div class="hero-list">';
                bestPlants.slice(0, 3).forEach((item) => {
                    const winRatePercent =
                        (item.winRate * 100).toFixed(1) + "%";
                    summaryHtml += `<div class="hero-item">${heroNames[item.hero]}: ${winRatePercent} win rate (${item.matches} games)</div>`;
                });
                summaryHtml += "</div></div>";

                // Overall faction stats
                const totalMatches = data.reduce(
                    (sum, m) => sum + m.totalMatches,
                    0,
                );
                const zombieWins = data.reduce(
                    (sum, m) => sum + m.zombieWins,
                    0,
                );
                const plantWins = data.reduce((sum, m) => sum + m.plantWins, 0);

                const zombieWinRate =
                    totalMatches > 0
                        ? ((zombieWins / totalMatches) * 100).toFixed(1) + "%"
                        : "N/A";
                const plantWinRate =
                    totalMatches > 0
                        ? ((plantWins / totalMatches) * 100).toFixed(1) + "%"
                        : "N/A";

                summaryHtml += `<div class="stats-section"><h3>Overall Faction Stats</h3>
                <p>Total Matches: ${totalMatches}</p>
                <p>Zombies: ${zombieWinRate} (${zombieWins} wins)</p>
                <p>Plants: ${plantWinRate} (${plantWins} wins)</p>
            </div>`;

                statsSummary.innerHTML = summaryHtml;
            }

            // Function to fetch the actual data from GitHub repo
            async function fetchDataFromGitHub(tournamentFullPath) {
                try {
                    const repoOwner = "Zintrall";
                    const repoName = "zintrall.github.io";

                    const response = await fetch(
                        `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/datafiles/${tournamentFullPath}`,
                    );
                    if (!response.ok) {
                        throw new Error(
                            `Failed to fetch data for ${tournamentFullPath} (${response.status})`,
                        );
                    }
                    const data = await response.text();
                    return processGameData(data.split("\n"));
                } catch (error) {
                    console.error(
                        `Error fetching data for ${tournamentFullPath}:`,
                        error,
                    );
                    return [];
                }
            }

            // Process the raw text data into structured format
            function processGameData(lines) {
                return lines
                    .filter((line) => line.trim().length > 0)
                    .map((line) => {
                        const [
                            timestamp,
                            winner,
                            loser,
                            winningHero,
                            losingHero,
                            ...rest
                        ] = line.split("|");
                        return {
                            timestamp,
                            winner,
                            loser,
                            winningHero,
                            losingHero,
                        };
                    });
            }

            // Render advanced player vs player comparison
            function renderAdvancedComparison(data, player1, player2) {
                const heroGrid = document.getElementById("hero-grid");
                const statsSummary = document.getElementById("stats-summary");

                // Filter matches between these two players
                const matches = data;

                if (matches.length === 0) {
                    heroGrid.innerHTML = `<div class="error">No matches found between ${player1} and ${player2}</div>`;
                    statsSummary.innerHTML = "";
                    return;
                }

                // Count wins for each player
                const player1Wins = matches.filter(
                    (m) => m.winner === player1,
                ).length;
                const player2Wins = matches.filter(
                    (m) => m.winner === player2,
                ).length;
                const totalMatches = matches.length;
                const player1WinRate = (
                    (player1Wins / totalMatches) *
                    100
                ).toFixed(1);
                const player2WinRate = (
                    (player2Wins / totalMatches) *
                    100
                ).toFixed(1);

                // Find each player's most used heroes
                const player1Heroes = {};
                const player2Heroes = {};

                matches.forEach((match) => {
                    if (match.winner === player1) {
                        player1Heroes[match.winningHero] =
                            (player1Heroes[match.winningHero] || 0) + 1;
                    } else if (match.loser === player1) {
                        player1Heroes[match.losingHero] =
                            (player1Heroes[match.losingHero] || 0) + 1;
                    }

                    if (match.winner === player2) {
                        player2Heroes[match.winningHero] =
                            (player2Heroes[match.winningHero] || 0) + 1;
                    } else if (match.loser === player2) {
                        player2Heroes[match.losingHero] =
                            (player2Heroes[match.losingHero] || 0) + 1;
                    }
                });

                const player1TopHeroes = Object.entries(player1Heroes)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([hero, count]) => ({ hero, count }));

                const player2TopHeroes = Object.entries(player2Heroes)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([hero, count]) => ({ hero, count }));

                // Generate hero matchups between these players
                const heroMatchups = {};

                matches.forEach((match) => {
                    let player1Hero, player2Hero;

                    if (match.winner === player1) {
                        player1Hero = match.winningHero;
                        player2Hero = match.losingHero;
                    } else {
                        player1Hero = match.losingHero;
                        player2Hero = match.winningHero;
                    }

                    const key = `${player1Hero}_${player2Hero}`;
                    if (!heroMatchups[key]) {
                        heroMatchups[key] = {
                            player1Hero,
                            player2Hero,
                            player1Wins: 0,
                            player2Wins: 0,
                            totalMatches: 0,
                        };
                    }

                    heroMatchups[key].totalMatches++;
                    if (match.winner === player1) {
                        heroMatchups[key].player1Wins++;
                    } else {
                        heroMatchups[key].player2Wins++;
                    }
                });

                // Sort matchups by number of games
                const topMatchups = Object.values(heroMatchups)
                    .sort((a, b) => b.totalMatches - a.totalMatches)
                    .slice(0, 5);

                // Generate HTML for comparison
                let comparisonHtml = `
                <div class="player-comparison">
                    <div class="head-to-head">
                        <div>
                            <span class="player-name">${player1}</span>
                            <div class="head-to-head-score">${player1Wins} (${player1WinRate}%)</div>
                        </div>
                        <div class="comparison-header">
                            <h3>${totalMatches} Total Matches</h3>
                        </div>
                        <div>
                            <span class="player-name">${player2}</span>
                            <div class="head-to-head-score">${player2Wins} (${player2WinRate}%)</div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 20px;">
                        <div class="player-card" style="flex: 1;">
                            <h3>Most Played Heroes - ${player1}</h3>
                            <div class="hero-list">
                                ${player1TopHeroes
                                    .map(
                                        (item) =>
                                            `<div class="player-hero">
                                        <span class="player-hero-name">${heroNames[item.hero] || item.hero}</span>
                                        <span class="player-hero-stats">${item.count} games</span>
                                    </div>`,
                                    )
                                    .join("")}
                            </div>
                        </div>
                        <div class="player-card" style="flex: 1;">
                            <h3>Most Played Heroes - ${player2}</h3>
                            <div class="hero-list">
                                ${player2TopHeroes
                                    .map(
                                        (item) =>
                                            `<div class="player-hero">
                                        <span class="player-hero-name">${heroNames[item.hero] || item.hero}</span>
                                        <span class="player-hero-stats">${item.count} games</span>
                                    </div>`,
                                    )
                                    .join("")}
                            </div>
                        </div>
                    </div>

                    <div class="player-card">
                        <h3>Top Hero Matchups</h3>
                        <table>
                            <tr>
                                <th>${player1}</th>
                                <th>${player2}</th>
                                <th>Score</th>
                                <th>Games</th>
                            </tr>
                            ${topMatchups
                                .map((matchup) => {
                                    const p1WinRate = (
                                        (matchup.player1Wins /
                                            matchup.totalMatches) *
                                        100
                                    ).toFixed(1);
                                    const bgColor = getWinRateColor(
                                        matchup.player1Wins /
                                            matchup.totalMatches,
                                    );
                                    return `<tr>
                                    <td>${heroNames[matchup.player1Hero] || matchup.player1Hero}</td>
                                    <td>${heroNames[matchup.player2Hero] || matchup.player2Hero}</td>
                                    <td style="background-color: ${bgColor}">${matchup.player1Wins}-${matchup.player2Wins} (${p1WinRate}%)</td>
                                    <td>${matchup.totalMatches}</td>
                                </tr>`;
                                })
                                .join("")}
                        </table>
                    </div>

                    <div class="player-card match-history">
                        <h3>Recent Matches</h3>
                        ${matches
                            .slice(0, 10)
                            .map((match) => {
                                const date = new Date(
                                    match.timestamp,
                                ).toLocaleDateString();
                                const time = new Date(
                                    match.timestamp,
                                ).toLocaleTimeString();
                                const isPlayer1Win = match.winner === player1;

                                return `<div class="match-item">
                                <div>
                                    <span class="${isPlayer1Win ? "match-result-win" : "match-result-loss"}">${isPlayer1Win ? "Win" : "Loss"}</span>
                                    <span>${date} ${time}</span>
                                </div>
                                <div>
                                    ${heroNames[match.winningHero] || match.winningHero} vs ${heroNames[match.losingHero] || match.losingHero}
                                </div>
                            </div>`;
                            })
                            .join("")}
                    </div>
                </div>
            `;

                heroGrid.innerHTML = comparisonHtml;
                statsSummary.innerHTML = "";
            }

            // Function to fetch and process the actual match data from text files
            async function fetchRealMatchData(
                dataFilter,
                selectedTournaments,
                playerFilter,
                useAllTournaments,
            ) {
                let allData = [];
                let tournamentPaths = selectedTournaments;

                // If all tournaments should be used, we need to get all available tournaments
                if (useAllTournaments) {
                    try {
                        const repoOwner = "Zintrall";
                        const repoName = "zintrall.github.io";

                        // If we're using all patches too, we need to get all patches first
                        let patches = [];
                        if (
                            dataFilter.type === "patch" &&
                            dataFilter.allPatches
                        ) {
                            const patchesPath = "datafiles";
                            const patchesApiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${patchesPath}`;

                            const patchesResponse = await fetch(patchesApiUrl);
                            if (patchesResponse.ok) {
                                const patchesData =
                                    await patchesResponse.json();
                                patches = patchesData
                                    .filter((item) => item.type === "dir")
                                    .map((item) => item.name);
                            }
                        } else if (dataFilter.type === "patch") {
                            patches = dataFilter.patches;
                        }

                        // Now get all tournaments for these patches
                        tournamentPaths = [];
                        for (const patch of patches) {
                            const path = `datafiles/${patch}`;
                            const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${path}`;

                            try {
                                const response = await fetch(apiUrl);
                                if (response.ok) {
                                    const data = await response.json();
                                    const tournaments = data
                                        .filter(
                                            (item) =>
                                                item.type === "file" &&
                                                item.name.endsWith(".txt"),
                                        )
                                        .map((item) => `${patch}/${item.name}`);

                                    tournamentPaths =
                                        tournamentPaths.concat(tournaments);
                                }
                            } catch (error) {
                                console.error(
                                    `Error fetching tournaments for patch ${patch}:`,
                                    error,
                                );
                            }
                        }
                    } catch (error) {
                        console.error("Error fetching all tournaments:", error);
                    }
                }

                // Fetch data for each tournament
                for (const tournamentPath of tournamentPaths) {
                    try {
                        const tournamentData =
                            await fetchDataFromGitHub(tournamentPath);

                        // Apply date filter if needed
                        if (
                            dataFilter.type === "date" &&
                            dataFilter.startDate &&
                            dataFilter.endDate
                        ) {
                            const startDate = new Date(dataFilter.startDate);
                            const endDate = new Date(dataFilter.endDate);
                            endDate.setHours(23, 59, 59); // Include the whole end day

                            const filteredData = tournamentData.filter(
                                (match) => {
                                    const matchDate = new Date(match.timestamp);
                                    return (
                                        matchDate >= startDate &&
                                        matchDate <= endDate
                                    );
                                },
                            );

                            allData = allData.concat(filteredData);
                        } else {
                            // No date filter, just add all data
                            allData = allData.concat(tournamentData);
                        }
                    } catch (error) {
                        console.error(
                            `Error processing tournament data for ${tournamentPath}:`,
                            error,
                        );
                    }
                }

                // Apply player filters
                if (playerFilter.type === "advanced") {
                    if (playerFilter.player1 && playerFilter.player2) {
                        allData = allData.filter(
                            (match) =>
                                (match.winner === playerFilter.player1 &&
                                    match.loser === playerFilter.player2) ||
                                (match.winner === playerFilter.player2 &&
                                    match.loser === playerFilter.player1),
                        );
                    }
                } else if (
                    playerFilter.type === "players" &&
                    !playerFilter.allPlayers
                ) {
                    allData = allData.filter(
                        (match) =>
                            playerFilter.players.includes(match.winner) ||
                            playerFilter.players.includes(match.loser),
                    );
                } else if (
                    playerFilter.type === "opponent" &&
                    playerFilter.opponent
                ) {
                    allData = allData.filter(
                        (match) =>
                            match.winner === playerFilter.opponent ||
                            match.loser === playerFilter.opponent,
                    );
                }

                // Process the data into the format needed for the win rate table
                return processMatchDataForWinRateTable(allData);
            }

            // Process match data into the format needed for the win rate table
            function processMatchDataForWinRateTable(matchData) {
                // Create a data structure to hold all matchups
                const matchups = {};

                // Initialize all matchups with zero counts
                heroes.zombies.forEach((zombie) => {
                    heroes.plants.forEach((plant) => {
                        const key = `${zombie}-${plant}`;
                        matchups[key] = {
                            zombie,
                            plant,
                            zombieWins: 0,
                            plantWins: 0,
                            totalMatches: 0,
                            zombieWinRate: 0,
                        };
                    });
                });

                // Process each match
                matchData.forEach((match) => {
                    let zombieHero, plantHero, zombieWin;

                    // Determine which hero is zombie and which is plant
                    if (heroes.zombies.includes(match.winningHero)) {
                        zombieHero = match.winningHero;
                        plantHero = match.losingHero;
                        zombieWin = true;
                    } else if (heroes.plants.includes(match.winningHero)) {
                        zombieHero = match.losingHero;
                        plantHero = match.winningHero;
                        zombieWin = false;
                    } else {
                        // If neither hero is recognized, skip this match
                        return;
                    }

                    // Update the matchup stats
                    const key = `${zombieHero}-${plantHero}`;
                    if (matchups[key]) {
                        matchups[key].totalMatches++;

                        if (zombieWin) {
                            matchups[key].zombieWins++;
                        } else {
                            matchups[key].plantWins++;
                        }

                        // Update win rate
                        matchups[key].zombieWinRate =
                            matchups[key].zombieWins /
                            matchups[key].totalMatches;
                    }
                });

                // Convert the object to an array
                return Object.values(matchups).filter(
                    (m) => m.totalMatches > 0,
                );
            }
        </script>
    </body>
</html>
